# $Id: jboss_4_0.dtd 73541 2008-05-20 22:17:16Z alex.loubyansky@jboss.com $
# 
# This is the XML DTD for the JBoss 4.0 EJB deployment descriptor.
# The DOCTYPE is:
# 
#   <!DOCTYPE jboss PUBLIC
#       "-//JBoss//DTD JBOSS 4.0//EN"
#       "http://www.jboss.org/j2ee/dtd/jboss_4_0.dtd">
# 
# Overview of the architecture of jboss.xml
# 
# <jboss>
# 
#   <enforce-ejb-restrictions />
#   <security-domain />
#   <unauthenticated-principal />
#   <webservices>
#     <context-root>
#     <webservice-description>
#       <webservice-description-name>
#       <wsdl-publish-location>
#     </webservice-description>
#   <webservices>
# 
#   <enterprise-beans>
# 
#     <entity>
#       <ejb-name />
#       <jndi-name />
#       <local-jndi-name />
#       <call-by-value>
#       <read-only>
#       <call-by-value>
#       <configuration-name>
#       <security-proxy>
#       <ejb-ref>
#       <ejb-local-ref>
#       <service-ref>
#       <security-identity>
#         <run-as-principal>
#       </security-identity>
#       <resource-ref>
#         <res-ref-name />
#         <resource-name />
#       </resource-ref>
#       <resource-env-ref>
#       <clustered />
#       <cluster-config>
#     </entity>
# 
#     <session>
#       <ejb-name />
#       <jndi-name />
#       <local-jndi-name />
#       <call-by-value>
#       <configuration-name>
#       <security-proxy>
#       <ejb-ref>
#       <ejb-local-ref>
#       <service-ref>
#       <security-identity>
#         <run-as-principal>
#       </security-identity>
#       <resource-ref>
#         <res-ref-name />
#         <resource-name />
#       </resource-ref>
#       <resource-env-ref>
#       <clustered />
#       <cluster-config>
#       <port-component>
#         <port-component-name>
#         <port-component-uri>
#         <auth-method>
#         <transport-guarantee>
#       </port-component>
#     </session>
# 
#     <message-driven>
#       <ejb-name>
#       <destination-jndi-name>
#       <mdb-user>
#       <mdb-passwd>
#       <mdb-client-id>
#       <mdb-subscription-id>
#       <resource-adapter-name>
#       <configuration-name>
#       <security-proxy>
#       <ejb-ref>
#       <service-ref>
#       <security-identity>
#         <run-as-principal>
#       </security-identity>
#       <resource-ref>
#       <resource-env-ref>
#     </message-driven>
# 
#   </enterprise-beans>
# 
#   <assembly-descriptor>
#     <security-role>
#       <role-name>
#       <principal-name>
#     </security-role>
#   </assembly-descriptor>
# 
#   <resource-managers>
# 
#     <resource-manager>
#       <res-name />
#       <res-jndi-name />
#     </resource-manager>
# 
#     <resource-manager>
#       <res-name />
#       <res-url />
#     </resource-manager>
# 
#   </resource-managers>
# 
#   <container-configurations>
# 
#     <container-configuration>
#       <container-name />
#       <call-logging />
#       <invoker-proxy-binding-name />
#       <sync-on-commit-only />
#       <insert-after-ejb-post-create />
#       <call-ejb-store-on-clean />
#       <store-not-flushed />
#       <container-interceptors />
#       <instance-pool />
#       <instance-cache />
#       <persistence-manager />
#       <web-class-loader />
#       <locking-policy />
#       <container-cache-conf />
#       <container-pool-conf />
#       <commit-option />
#       <optiond-refresh-rate />
#       <security-domain />
#       <cluster-config />
#       <depends />
#     </container-configuration>
# 
#   </container-configurations>
# 
# </jboss>

namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"

include "service-ref_4_0.rnc"
# The jboss element is the root element of the jboss.xml file. It
# contains all the information used by jboss but not described in the
# ejb-jar.xml file. All of it is optional.
# 
# 1- the application assembler can define custom container configurations
#    for the beans. Standard configurations are provided in standardjboss.xml
# 2- the deployer can override the jndi names under which the beans are deployed
# 3- the deployer can specify runtime jndi names for resource managers.
#
jboss =
  element jboss {
    attlist.jboss,
    loader-repository?,
    jmx-name?,
    enforce-ejb-restrictions?,
    security-domain?,
    missing-method-permissions-excluded-mode?,
    unauthenticated-principal?,
    exception-on-rollback?,
    webservices?,
    enterprise-beans?,
    assembly-descriptor?,
    resource-managers?,
    invoker-proxy-bindings?,
    container-configurations?
  }
attlist.jboss &= empty
# The loader-repository specifies the name of the UnifiedLoaderRepository
#    MBean to use for the ear to provide ear level scoping of classes deployed
#    in the ear. It is a unique JMX ObjectName string. It may also specify
#    an arbitrary configuration by including a loader-repository-config element.
# 
# Examples:
#    <loader-repository>jboss.test:loader=cts-cmp2v1-sar.ear</loader-repository>
# 
#    <loader-repository loaderRepositoryClass='dot.com.LoaderRepository'>
#       dot.com:loader=unique-archive-name
#       <loader-repository-config configParserClass='dot.com.LoaderParser'>
#          java2ParentDelegaton=true
#       </loader-repository-config>
#    </loader-repository>
loader-repository =
  element loader-repository {
    attlist.loader-repository, (text | loader-repository-config)*
  }
# The loaderRepositoryClass attribute gives the classname of the
# org.jboss.mx.loading.LoaderRepository implementation.
attlist.loader-repository &= attribute loaderRepositoryClass { text }?
# The loader-repository-config element specifies any arbitrary configuration
# fragment for use in configuring the loader-repository instance. The actual
# content of this element is specific to the loaderRepositoryClass and the
# code parsing the element.
loader-repository-config =
  element loader-repository-config {
    attlist.loader-repository-config, text
  }
# The configParserClass attribute gives the classname of the
# org.jboss.mx.loading.LoaderRepositoryFactory.LoaderRepositoryConfigParser
# implementation to use to parse the loader-repository-config content.
attlist.loader-repository-config &=
  attribute configParserClass { text }?
# The jmx-name element allows one to specify the JMX ObjectName to use
# for the MBean associated with the ejb-jar module. This must be a unique
# name and valid JMX ObjectName string.
# 
#    Used in: jboss
jmx-name = element jmx-name { attlist.jmx-name, text }
attlist.jmx-name &= empty
# The enforce-ejb-restrictions element tells the container to enforce ejb1.1 restrictions
# It must be one of the following :
#   <enforce-ejb-restrictions>true</enforce-ejb-restrictions>
#   <enforce-ejb-restrictions>false</enforce-ejb-restrictions>
# 
# Used in: jboss
enforce-ejb-restrictions =
  element enforce-ejb-restrictions {
    attlist.enforce-ejb-restrictions, text
  }
attlist.enforce-ejb-restrictions &= empty
# The security-domain element specifies the JNDI name of the security
# manager that implements the EJBSecurityManager and RealmMapping for
# the domain. When specified at the jboss level it specifies the security
# domain for all j2ee components in the deployment unit.
# One can override the global security-domain at the container
# level using the security-domain element at the container-configuration
# level.
# 
# Used in: jboss, container-configuration
security-domain =
  element security-domain { attlist.security-domain, text }
attlist.security-domain &= empty
# The missing-method-permissions-excluded-mode determines the treatment
# of missing method-permission mappings in the ejb-jar descriptor. The ejb 2.1
# spec states: "It is possible that some methods are not assigned to any security
# roles nor contained in the exclude-list element. In this case, it is the
# responsibility of the Deployer to assign method permissions for all of the
# unspecified methods, either by assigning them to security roles, or by marking
# them as unchecked." The missing-method-permissions-excluded-mode is a boolean
# that allows the deployer to globally indicate that all methods without a
# method-permission element should be treated as excluded(= true and the default),
# or that methods without a method-permission element should be treated as
# unchecked(= false)
# 
# <missing-method-permissions-excluded-mode>true</missing-method-permissions-excluded-mode>
# <missing-method-permissions-excluded-mode>false</missing-method-permissions-excluded-mode>
#
missing-method-permissions-excluded-mode =
  element missing-method-permissions-excluded-mode {
    attlist.missing-method-permissions-excluded-mode, text
  }
attlist.missing-method-permissions-excluded-mode &= empty
# The unauthenticated-principal element specifies the name of the principal
# that will be returned by the EJBContext.getCallerPrincipal() method if there
# is no authenticated user. This Principal has no roles or privaledges to call
# any other beans.
unauthenticated-principal =
  element unauthenticated-principal {
    attlist.unauthenticated-principal, text
  }
attlist.unauthenticated-principal &= empty
# The invoker-proxy-bindings defines the invokers available for use with
# the ejb container configurations.
invoker-proxy-bindings =
  element invoker-proxy-bindings {
    attlist.invoker-proxy-bindings, invoker-proxy-binding*
  }
attlist.invoker-proxy-bindings &= empty
# The invoker-proxy-binding defines an invoker service and proxy factory
invoker-proxy-binding =
  element invoker-proxy-binding {
    attlist.invoker-proxy-binding,
    name,
    invoker-mbean,
    proxy-factory,
    proxy-factory-config
  }
attlist.invoker-proxy-binding &= empty
# The name gives a unique name for the invoker-proxy-binding
name = element name { attlist.name, text }
attlist.name &= empty
# The invoker-mbean gives the JMX ObjectName of the invoker MBean service
invoker-mbean = element invoker-mbean { attlist.invoker-mbean, text }
attlist.invoker-mbean &= empty
# The org.jboss.ejb.EJBProxyFactory implementation class
proxy-factory = element proxy-factory { attlist.proxy-factory, text }
attlist.proxy-factory &= empty
# The proxy-factory-config defines the client-interceptors stack
# and other configuration options to use for the various EJB proxies.
proxy-factory-config =
  element proxy-factory-config {
    attlist.proxy-factory-config,
    client-interceptors?,
    endpoint-interceptors?,
    web-class-loader?,
    activation-config?,
    JMSProviderAdapterJNDI?,
    ServerSessionPoolFactoryJNDI?,
    CreateJBossMQDestination?,
    MinimumSize?,
    MaximumSize?,
    KeepAliveMillis?,
    MaxMessages?,
    MDBConfig?,
    poa?,
    register-ejbs-in-jnp-context?,
    jnp-context?,
    interface-repository-supported?
  }
attlist.proxy-factory-config &= empty
# The jndi name of the jms provider adapter in the java:/ namespace.
# This is mandatory for an MDB and must implement
# org.jboss.jms.jndi.JMSProviderAdapter
# 
# Used in: proxy-factory-config for JMSContainerInvoker
JMSProviderAdapterJNDI =
  element JMSProviderAdapterJNDI {
    attlist.JMSProviderAdapterJNDI, text
  }
attlist.JMSProviderAdapterJNDI &= empty
# The jndi name of the session pool in the java:/ namespace.
# This is mandatory for an MDB and must implement
# org.jboss.jms.asf.ServerSessionPoolFactory
# 
# Used in: proxy-factory-config for JMSContainerInvoker
ServerSessionPoolFactoryJNDI =
  element ServerSessionPoolFactoryJNDI {
    attlist.ServerSessionPoolFactoryJNDI, text
  }
attlist.ServerSessionPoolFactoryJNDI &= empty
# Whether to create destinations in JBossMQ if the
# destination cannot be found.
# 
# Used in: proxy-factory-config for JMSContainerInvoker
CreateJBossMQDestination =
  element CreateJBossMQDestination {
    attlist.CreateJBossMQDestination, text
  }
attlist.CreateJBossMQDestination &= empty
# The maximum number of messages parameter for the mdb's
# connection consumer.
# 
# Used in: proxy-factory-config for JMSContainerInvoker
MaxMessages = element MaxMessages { attlist.MaxMessages, text }
attlist.MaxMessages &= empty
# Configuration for the MDB
# 
# Used in: proxy-factory-config for JMSContainerInvoker
MDBConfig =
  element MDBConfig {
    attlist.MDBConfig, ReconnectIntervalSec, DeliveryActive?, DLQConfig?
  }
attlist.MDBConfig &= empty
# The time to wait (in seconds) before trying to recover
# the connection to the JMS server.
# 
# Used in: MDBConfig
ReconnectIntervalSec =
  element ReconnectIntervalSec { attlist.ReconnectIntervalSec, text }
attlist.ReconnectIntervalSec &= empty
# Whether delivery of messages is active at startup,
# valid values are "True" or "False".
# 
# Used in: MDBConfig
DeliveryActive = element DeliveryActive { attlist.DeliveryActive, text }
attlist.DeliveryActive &= empty
# Configuration for an MDB's dead letter queue, used
# when messages are redelivered too many times.
# 
# Used in: MDBConfig
DLQConfig =
  element DLQConfig {
    attlist.DLQConfig,
    DestinationQueue,
    MaxTimesRedelivered,
    TimeToLive,
    DLQUser?,
    DLQPassword?
  }
attlist.DLQConfig &= empty
# The jndi name of the queue to use as the dead letter queue.
# 
# Used in: DLQConfig
DestinationQueue =
  element DestinationQueue { attlist.DestinationQueue, text }
attlist.DestinationQueue &= empty
# The maximum number of times a message is redelivered before it
# is placed in the dead letter queue.
# 
# Used in: DLQConfig
MaxTimesRedelivered =
  element MaxTimesRedelivered { attlist.MaxTimesRedelivered, text }
attlist.MaxTimesRedelivered &= empty
# The time-to-live of the message in the dead letter queue.
# See javax.jms.Message
# 
# Used in: DLQConfig
TimeToLive = element TimeToLive { attlist.TimeToLive, text }
attlist.TimeToLive &= empty
# The user for the dlq connection
# 
# Used in: DLQConfig
DLQUser = element DLQUser { attlist.DLQUser, text }
attlist.DLQUser &= empty
# The password for the dlq connection
# 
# Used in: DLQConfig
DLQPassword = element DLQPassword { attlist.DLQPassword, text }
attlist.DLQPassword &= empty
# The portable object adapter usage, one of
# <poa>per-servent</poa>
# <poa>shared</poa>
# 
# Used in: proxy-factory-config for IORFactory
poa = element poa { attlist.poa, text }
attlist.poa &= empty
# Whether to register ejbs in jnp (jndi)
# 
# Used in: proxy-factory-config for IORFactory
register-ejbs-in-jnp-context =
  element register-ejbs-in-jnp-context {
    attlist.register-ejbs-in-jnp-context, text
  }
attlist.register-ejbs-in-jnp-context &= empty
# The jndi context in which to register ejbs
# 
# Used in: proxy-factory-config for IORFactory
jnp-context = element jnp-context { attlist.jnp-context, text }
attlist.jnp-context &= empty
# Whether a deployed ejb has its own CORBA interface repository or not
# 
# Used in: proxy-factory-config for IORFactory
interface-repository-supported =
  element interface-repository-supported {
    attlist.interface-repository-supported, text
  }
attlist.interface-repository-supported &= empty
# The enterprise-beans element contains additional information about
# the beans. These informations, such as jndi names, resource managers and
# container configurations, are specific to jboss and not described in
# ejb-jar.xml.
# 
# jboss will provide a standard behaviour if no enterprise-beans element
# is found, see container-configurations, jndi-name and resource-managers
# for defaults.
# 
# Used in: jboss
webservices =
  element webservices {
    attlist.webservices, context-root?, webservice-description*
  }
attlist.webservices &= empty
# The context-root element specifies the context root of the web
# application that the EJB service endpoints are deployed to. 
# If it is not specified it will be derived from the deployment short name.
context-root = element context-root { attlist.context-root, text }
attlist.context-root &= empty
# Runtime information about a web service.
# wsdl-publish-location is optionally used to specify
# where the final wsdl and any dependent files should be stored.  This location
# resides on the file system from which deployment is initiated.
webservice-description =
  element webservice-description {
    attlist.webservice-description,
    webservice-description-name,
    config-name?,
    config-file?,
    wsdl-publish-location?
  }
attlist.webservice-description &= empty
# Unique name of a webservice within a module. It corresponds to the <webservice-description-name>
# element in webservices.xml
webservice-description-name =
  element webservice-description-name {
    attlist.webservice-description-name, text
  }
attlist.webservice-description-name &= empty
# file: URL of a directory to which a web-service-description's wsdl should be
# published during deployment.  Any required files will be published to this
# directory, preserving their location relative to the module-specific
# wsdl directory(META-INF/wsdl or WEB-INF/wsdl).
# Example :
#   For an ejb.jar whose webservices.xml wsdl-file element contains
#     META-INF/wsdl/a/Foo.wsdl
#   <wsdl-publish-location>file:/home/user1/publish
#   </wsdl-publish-location>
#   The final wsdl will be stored in /home/user1/publish/a/Foo.wsdl
wsdl-publish-location =
  element wsdl-publish-location { attlist.wsdl-publish-location, text }
attlist.wsdl-publish-location &= empty
# The enterprise-beans element contains additional information about
# the beans. These informations, such as jndi names, resource managers and
# container configurations, are specific to jboss and not described in
# ejb-jar.xml.
# jboss will provide a standard behaviour if no enterprise-beans element
# is found, see container-configurations, jndi-name and resource-managers
# for defaults.
# Used in: jboss
enterprise-beans =
  element enterprise-beans {
    attlist.enterprise-beans, (session | entity | message-driven)*
  }
attlist.enterprise-beans &= empty
# The entity element holds information specific to jboss and not declared
# in ejb-jar.xml about an entity bean, such as jndi name, container
# configuration, and resource managers. (see tags for details)
# The bean should already be declared in ejb-jar.xml, with the same
# ejb-name.
# 
# Used in: enterprise-beans
entity =
  element entity {
    attlist.entity,
    ejb-name,
    jndi-name?,
    local-jndi-name?,
    call-by-value?,
    read-only?,
    exception-on-rollback?,
    timer-persistence?,
    configuration-name?,
    invoker-bindings?,
    security-proxy?,
    ejb-ref*,
    ejb-local-ref*,
    service-ref*,
    security-identity?,
    resource-ref*,
    resource-env-ref*,
    message-destination-ref*,
    method-attributes?,
    clustered?,
    cluster-config?,
    cache-invalidation?,
    cache-invalidation-config?,
    depends*,
    ior-security-config?
  }
# Allow the entity to have a unique id
attlist.entity &= attribute id { xsd:ID }?
# The session element holds information specific to jboss and not declared
# in ejb-jar.xml about a session bean, such as jndi name, container
# configuration, and resource managers. (see tags for details)
# The bean should already be declared in ejb-jar.xml, with the same
# ejb-name.
# 
# Used in: enterprise-beans
session =
  element session {
    attlist.session,
    ejb-name,
    jndi-name?,
    local-jndi-name?,
    call-by-value?,
    exception-on-rollback?,
    timer-persistence?,
    configuration-name?,
    invoker-bindings?,
    security-proxy?,
    ejb-ref*,
    ejb-local-ref*,
    service-ref*,
    security-identity?,
    resource-ref*,
    resource-env-ref*,
    message-destination-ref*,
    clustered?,
    cluster-config?,
    method-attributes?,
    depends*,
    ior-security-config?,
    port-component*,
    ejb-timeout-identity?
  }
# Allow the session to have a unique id
attlist.session &= attribute id { xsd:ID }?
# The message-driven element holds information specific to jboss and not declared
# in ejb-jar.xml about a message-driven bean, such as container
# configuration and resources.
# The bean should already be declared in ejb-jar.xml, with the same
# ejb-name.
# 
# Used in: enterprise-beans
message-driven =
  element message-driven {
    attlist.message-driven,
    ejb-name,
    activation-config?,
    destination-jndi-name?,
    local-jndi-name?,
    mdb-user?,
    mdb-passwd?,
    mdb-client-id?,
    mdb-subscription-id?,
    resource-adapter-name?,
    exception-on-rollback?,
    timer-persistence?,
    configuration-name?,
    invoker-bindings?,
    security-proxy?,
    ejb-ref*,
    ejb-local-ref*,
    service-ref*,
    security-identity?,
    resource-ref*,
    resource-env-ref*,
    message-destination-ref*,
    depends*,
    ior-security-config?,
    ejb-timeout-identity?
  }
# Allow the message-driven to have a unique id
attlist.message-driven &= attribute id { xsd:ID }?
# The ejb-name element gives the name of the bean, it must correspond to
# an ejb-name element in ejb-jar.xml
# 
# Used in: entity, session, and message-driven
ejb-name = element ejb-name { attlist.ejb-name, text }
attlist.ejb-name &= empty
# The jndi-name element gives the actual jndi name under which
# the bean will be deployed when used in the entity, session and
# message-driven elements. If it is not provided jboss will assume
# "jndi-name" = "ejb-name"
# 
# When used in the ejb-ref,  ejb-local-ref, resource-ref, resource-env-ref, 
# message-destination-ref, message-destination elements this specifies the jndi name to 
# which the reference should link.
# 
# Used in: entity, session and message-driven
#   ejb-ref, resource-ref, resource-env-ref
jndi-name = element jndi-name { attlist.jndi-name, text }
attlist.jndi-name &= empty
# The JNDI name under with the local home interface should be bound
# 
# Used in: entity and session
local-jndi-name =
  element local-jndi-name { attlist.local-jndi-name, text }
attlist.local-jndi-name &= empty
# Determine if the bean should use by value call semantics
# 
# Used in: entity and session
call-by-value = element call-by-value { attlist.call-by-value, text }
attlist.call-by-value &= empty
# The read-only element flags an entity bean as read only.
# The bean will never be ejbStored. Defaults to false.
# It must be one of the following :
#   <read-only>true</read-only>
#   <read-only>false</read-only>
# 
# Used in: entity
read-only = element read-only { attlist.read-only, text }
attlist.read-only &= empty
# Whether to throw an exception if the CMT controlled
# transaction is no longer active (e.g. marked rollback)
# but the application has not itself thrown an exception.
# If the bean specifies false, it uses the
# jboss/exception-on-rollback config.
# Defaults to false.
# It must be one of the following :
#   <exception-on-rollback>true</exception-on-rollback>
#   <exception-on-rollback>false</exception-on-rollback>
# 
# Used in: jboss, session, entity and message-driven
exception-on-rollback =
  element exception-on-rollback { attlist.exception-on-rollback, text }
attlist.exception-on-rollback &= empty
# The timer-persistence element determines whether ejb timers should
# be persisted across application redeployment. Defaults to true.
# 
# It must be one of the following:
#   <timer-persistence>true</timer-persistence>
#   <timer-persistence>false</timer-persistence>
# 
# Used in: session, entity and message-driven
timer-persistence =
  element timer-persistence { attlist.timer-persistence, text }
attlist.timer-persistence &= empty
# The configuration-name element gives the name of the container
# configuration for this bean. It must match one of the container-name
# tags in the container-configurations section, or one of the standard
# configurations. If no element is provided, jboss will automatically use the
# right standard configuration, see container-configurations.
# 
# Note: unlike earlier releases, this element may not be specified as an
#  empty element to achieve the same effect as not specifying the element.
# 
# Used in: entity, session, and message-driven
configuration-name =
  element configuration-name { attlist.configuration-name, text }
attlist.configuration-name &= empty
# The depends element gives a JMX ObjectName of a service on which the
# container or ejb depends.
depends = element depends { attlist.depends, text }
attlist.depends &= empty
# The queue/topic jndi name from which we receive messages
destination-jndi-name =
  element destination-jndi-name { attlist.destination-jndi-name, text }
attlist.destination-jndi-name &= empty
# The optional user for the jms connection that delivers messages
mdb-user = element mdb-user { attlist.mdb-user, text }
attlist.mdb-user &= empty
# The optional password for the jms connection that delivers messages
mdb-passwd = element mdb-passwd { attlist.mdb-passwd, text }
attlist.mdb-passwd &= empty
# The optional client-id for the jms connection that delivers messages
mdb-client-id = element mdb-client-id { attlist.mdb-client-id, text }
attlist.mdb-client-id &= empty
# The subscription name for topic delivery
mdb-subscription-id =
  element mdb-subscription-id { attlist.mdb-subscription-id, text }
attlist.mdb-subscription-id &= empty
# The name of the rar used in JCA 1.5 message inflow
# e.g.
#    <resource-adapter-name>jms-ra.rar</resource-adapter-name>
# or for embedded rars
#    <resource-adapter-name>myapp.ear#myconnector.rar</resource-adapter-name>
resource-adapter-name =
  element resource-adapter-name { attlist.resource-adapter-name, text }
attlist.resource-adapter-name &= empty
# The security-proxy gives the class name of the security proxy implementation.
# This may be an instance of org.jboss.security.SecurityProxy, or an
# just an object that implements methods in the home or remote interface
# of an EJB without implementating any common interface.
# 
#     Used in: entity, session, and message-driven
security-proxy = element security-proxy { attlist.security-proxy, text }
attlist.security-proxy &= empty
# The ejb-ref element is used to give the jndi-name of an external
# ejb reference. In the case of an external ejb reference, you don't
# provide a ejb-link element in ejb-jar.xml, but you provide a jndi-name
# in jboss.xml
# 
# Used in: entity, session, and message-driven
ejb-ref = element ejb-ref { attlist.ejb-ref, ejb-ref-name, jndi-name }
attlist.ejb-ref &= empty
# The ejb-ref-name element is the name of the ejb reference as given in
# ejb-jar.xml.
# 
# Used in: ejb-ref
ejb-ref-name = element ejb-ref-name { attlist.ejb-ref-name, text }
attlist.ejb-ref-name &= empty
# The ejb-local-ref element is used to give the jndi-name of an external
# ejb reference. This is an alternative to using ejb-link in ejb-jar.xml
# 
# Used in: entity, session, and message-driven
ejb-local-ref =
  element ejb-local-ref {
    attlist.ejb-local-ref, ejb-ref-name, local-jndi-name
  }
attlist.ejb-local-ref &= empty
# The security-identity element specifies whether a specific run-as identity is to be
# used. If there is a run-as role defined for an enterprise bean, there can also be a
# run-as-principal define here. If you don't define a run-as principal the callee will
# see ctx.getCallerPrincipal() == 'anonymous'
# 
# Used in: entity, message-driven, session
security-identity =
  element security-identity {
    attlist.security-identity, run-as-principal
  }
attlist.security-identity &= empty
# The ejb-timeout-identity element specifies the run-as used for the ejbTimeout
# callback method. If the run-as-principal is specified this is the identity
# that will be set as the callback run-as. If the run-as-principal is empty,
# then no security context is specified at the container level. Any access of
# secured resources will require that the ejbTimeout method establish the
# security context.
ejb-timeout-identity =
  element ejb-timeout-identity {
    attlist.ejb-timeout-identity, run-as-principal
  }
attlist.ejb-timeout-identity &= empty
# The run-as-principal element is the name of the principal that is used
# when the enterprise bean calls out with a run-as role.
# 
# Used in: security-identity
run-as-principal =
  element run-as-principal { attlist.run-as-principal, text }
attlist.run-as-principal &= empty
# The resource-env-ref element gives a mapping between the "code name"
# of a env resource (res-ref-name, provided by the Bean Developer) and
# its deployed JNDI name.
# 
# Used in: session, entity, message-driven
resource-env-ref =
  element resource-env-ref {
    attlist.resource-env-ref, resource-env-ref-name, jndi-name
  }
attlist.resource-env-ref &= empty
# The resource-env-ref-name element gives the "code name" of a resource. It is
# provided by the Bean Developer.
# 
# Used in: resource-env-ref
resource-env-ref-name =
  element resource-env-ref-name { attlist.resource-env-ref-name, text }
attlist.resource-env-ref-name &= empty
# The method-attributes element can be used to specify which methods are read only
# or idempotent.  This is used to reduce the need for locks and replication.
method-attributes =
  element method-attributes { attlist.method-attributes, method* }
attlist.method-attributes &= empty
# The method element is used to specify attributes for one method or all those
# matching a pattern startingstring*.
method =
  element method {
    attlist.method,
    method-name,
    read-only?,
    idempotent?,
    transaction-timeout?
  }
attlist.method &= empty
# The method-name element specifies a complete method name or a pattern consisting of an
# initial match followed by '*'
method-name = element method-name { attlist.method-name, text }
attlist.method-name &= empty
# The idempotent element is used in method-attributes to indicate that a method
# is completely stateless. Really the same as read-only and should be dropped.
idempotent = element idempotent { attlist.idempotent, text }
attlist.idempotent &= empty
# The transaction timeout in seconds (overriding the default timeout).
# This will only work for Required (where the method starts the transaction) and RequiresNew.
# The special value of 0 (zero) uses the default timeout configured on jboss:service=TransactionManager
# NOTE: any subsequent use of RequiresNew that is not explicitly overridden will use this value.
transaction-timeout =
  element transaction-timeout { attlist.transaction-timeout, text }
attlist.transaction-timeout &= empty
# The clustered element indicates if this bean will run in a cluster of JBoss instances.
# It is provided by the deployer. If not, jboss will assume clustered = False
# Possible values: "True", "False" (default)
# 
# Used in: entity and session
clustered = element clustered { attlist.clustered, text }
attlist.clustered &= empty
# The cluster-config element allows to specify cluster specific settings.
# WARNING: session-state-manager-jndi-name is only for SFSB.
# 
# Used in: session, entity, container-configuration
cluster-config =
  element cluster-config {
    attlist.cluster-config,
    partition-name?,
    home-load-balance-policy?,
    bean-load-balance-policy?,
    session-state-manager-jndi-name?
  }
attlist.cluster-config &= empty
# The partition-name element indicates the name of the HAPartition to be used
# by the container to exchange clustering information. This is a name and *not*
# a JNDI name. Given name will be prefixed by "/HAPartition/" by the container to get
# the actual JNDI name of the HAPartition. 
# 
# Must be set; there is no hard coded default. Can be set either in a bean's own 
# cluster-config element or in a container-configuration used by the bean.
# The standard clustered bean container configurations in conf/standardjboss.xml
# set this to the value of system property "jboss.partition.name", or 
# "DefaultPartition" if that property is not set.
# 
# Used in: entity, session and container-configuration (in clustered-config element)
partition-name = element partition-name { attlist.partition-name, text }
attlist.partition-name &= empty
# The home-load-balance-policy element indicates the java class name to be used
# to load balance calls in the home proxy. 
# 
# Must be set; there is no hard coded default. Can be set either in a bean's own 
# cluster-config element or in a container-configuration used by the bean.
# The standard clustered bean container configurations in conf/standardjboss.xml
# set this to "org.jboss.ha.framework.interfaces.RoundRobin".
# 
# Used in: entity, session and container-configuration (in cluster-config element)
home-load-balance-policy =
  element home-load-balance-policy {
    attlist.home-load-balance-policy, text
  }
attlist.home-load-balance-policy &= empty
# The bean-load-balance-policy element indicates the java class name to be used
# to load balance calls in an EJB2 bean proxy. 
# 
# Must be set; there is no hard coded default. Can be set either in a bean's own 
# cluster-config element or in a container-configuration used by the bean.
# The standard clustered bean container configurations in conf/standardjboss.xml
# set this to "org.jboss.ha.framework.interfaces.RoundRobin" for SLSBs and to
# "org.jboss.ha.framework.interfaces.FirstAvailable" for EB and SFSBs.
# 
# Used in: entity, session and container-configuration (in cluster-config element)
bean-load-balance-policy =
  element bean-load-balance-policy {
    attlist.bean-load-balance-policy, text
  }
attlist.bean-load-balance-policy &= empty
# The cache-invalidation element indicates if this bean cache should listen to cache
# invalidation events and clear its cache accordingly as well as send cache invalidation
# messages.
# It is provided by the deployer. If not, jboss will assume cache-invalidation = False
# NOTE: This value will *only* be applied if the correct cache plugin and interceptor(s)
#       are defined in the container configuration.
# Possible values: "True", "False" (default)
# 
# Used in: entity (only commit-option A and D will invalidate their cache)
cache-invalidation =
  element cache-invalidation { attlist.cache-invalidation, text }
attlist.cache-invalidation &= empty
# The cache-invalidation-config element allows to specify cache invalidation specific settings.
# 
# Used in: entity
cache-invalidation-config =
  element cache-invalidation-config {
    attlist.cache-invalidation-config,
    invalidation-group-name?,
    invalidation-manager-name?
  }
attlist.cache-invalidation-config &= empty
# The invalidation-group-name element indicates the name of a group in which all
# invalidation messages are exchanged i.e. all beans sharing a given invalidation-group-name
# should share the same PK semantic.
# By default, invalidation-group-name equals to the EJB name. Thus, when using cache invalidation
# accross a cluster, it is not necessary to specify a name as all beans will have the same name
# accross the cluster. Nevertheless, if you deploy, on the same node, the same EJB, once with
# commit-option C (RW access) and once in commit-option A (RO) and want the RW EJB to invalidate
# entries of RO EJB, each one will obviously have its own EJB name. Consequently, you can assign
# a common invalidation-group-name to both EJBs so that they share their cache invalidation messages.
# 
# Used in: entity (in cache-invalidation-config element)
invalidation-group-name =
  element invalidation-group-name {
    attlist.invalidation-group-name, text
  }
attlist.invalidation-group-name &= empty
# The invalidation-manager-name references the InvalidationManager MBean to be used.
# By Default, the default InvalidationManager is used.
# 
# Used in: entity (in cache-invalidation-config element)
invalidation-manager-name =
  element invalidation-manager-name {
    attlist.invalidation-manager-name, text
  }
attlist.invalidation-manager-name &= empty
# The session-state-manager-jndi-name element indicates the name of the 
# HASessionState to be used by the container as a backend for EJB2 stateful 
# session bean management in the cluster. This *is* a JNDI name (unlike the 
# partition-name element). 
# 
# Must be set; there is no hard coded default. Can be set either in a bean's own 
# cluster-config element or in a container-configuration used by the bean.
# The standard clustered bean container configurations in conf/standardjboss.xml
# set this to "/HASessionState/" plus the value of system property 
# "jboss.partition.name", or "DefaultPartition" if that property is not set.
# 
# Used in: session or container-configuration (in cluster-config element)
session-state-manager-jndi-name =
  element session-state-manager-jndi-name {
    attlist.session-state-manager-jndi-name, text
  }
attlist.session-state-manager-jndi-name &= empty
# The resource-ref element gives a mapping between the "code name"
# of a resource (res-ref-name, provided by the Bean Developer) and
# its "xml name" (resource-name, provided by the Application Assembler).
# If no resource-ref is provided, jboss will assume that
# "xml-name" = "code name"
# 
# See resource-managers.
# 
# Used in: entity, session, and message-driven
resource-ref =
  element resource-ref {
    attlist.resource-ref,
    res-ref-name,
    (resource-name | jndi-name | res-url)
  }
attlist.resource-ref &= empty
# The res-ref-name element gives the "code name" of a resource. It is
# provided by the Bean Developer. See resource-managers for the actual
# configuration of the resource.
# 
# Used in: resource-ref
res-ref-name = element res-ref-name { attlist.res-ref-name, text }
attlist.res-ref-name &= empty
# The resource-name element gives the "xml name" of the resource. It is
# provided by the Application Assembler. See resource-managers for the
# actual configuration of the resource.
# 
# Used in: resource-ref
resource-name = element resource-name { attlist.resource-name, text }
attlist.resource-name &= empty
# The resource-managers element is used to declare resource managers.
# 
# A resource has 3 names:
# - the "code name" is the name used in the code of the bean, supplied by
#   the Bean Developer in the resource-ref section of the ejb-jar.xml file
# 
# - the "xml name" is an intermediary name used by the Application Assembler
#   to identify resources in the XML file.
# 
# - the "runtime jndi name" is the actual jndi-name or url of the deployed
#   resource, it is supplied by the Deployer.
# 
# The mapping between the "code name" and the "xml name" is given
# in the resource-ref section for the bean. If not, jboss will assume that
# "xml name" = "code name".
# 
# The mapping between the "xml name" and the "runtime jndi name" is given in
# a resource-manager section. If not, and if the datasource is of type
# javax.sql.DataSource, jboss will look for a javax.sql.DataSource in the jndi
# tree.
# 
# Used in: jboss
resource-managers =
  element resource-managers {
    attlist.resource-managers, resource-manager*
  }
attlist.resource-managers &= empty
# The resource-manager element is used to provide a mapping between the
# "xml name" of a resource (res-name) and its "runtime jndi name"
# (res-jndi-name or res-url according to the type of the resource).
# If it is not provided, and if the type of the resource is
# javax.sql.DataSource, jboss will look for a javax.sql.DataSource in the
# jndi tree.
# 
# See resource-managers.
# 
# Used in: resource-managers
resource-manager =
  element resource-manager {
    attlist.resource-manager, res-name, (res-jndi-name | res-url)
  }
attlist.resource-manager &= empty
# The res-name element gives the "xml name" of a resource, it is provided
# by the Application Assembler. See resource-managers.
# 
# Used in: resource-manager
res-name = element res-name { attlist.res-name, text }
attlist.res-name &= empty
# The res-jndi-name element is the "deployed jndi name" of a resource, it
# is provided by the Deployer. See resource-managers.
# 
# Used in: resource-manager
res-jndi-name = element res-jndi-name { attlist.res-jndi-name, text }
attlist.res-jndi-name &= empty
# The res-url element value is a URL string for a resource-ref of
# res-type = java.net.URL. Using a res-url creates a binding of the URL
# instance under the java:comp/env. If you want to link to another binding
# of a URL, you can use the jndi-name to do so.
# 
# // Binds the URL(http://x.y.z) under java:comp/env/jdbc/XYZHome
# <resource-ref>
#     <res-ref-name>jdbc/XYZHome</res-ref-name>
#     <res-url>http://x.y.z</res-url>
# </resource-ref>
# // Binds a link to urls/XYZHomePage under java:comp/env/jdbc/XYZHome
# <resource-ref>
#     <res-ref-name>jdbc/XYZHome</res-ref-name>
#     <res-url>urls/XYZHomePage</res-url>
# </resource-ref>
# 
#    Used in: resource-ref, resource-manager
res-url = element res-url { attlist.res-url, text }
attlist.res-url &= empty
# The message-destination-ref element is used to configure the
# jndi-name for a message-destination-ref in ejb-jar.xml
# 
# Used in: entity, session, and message-driven
message-destination-ref =
  element message-destination-ref {
    attlist.message-destination-ref,
    message-destination-ref-name,
    jndi-name
  }
attlist.message-destination-ref &= empty
# The message-destination-ref-name element identifies the
# message-destination-ref. It must match the name in ejb-jar.xml
# 
# Used in: message-destination-ref
message-destination-ref-name =
  element message-destination-ref-name {
    attlist.message-destination-ref-name, text
  }
attlist.message-destination-ref-name &= empty
# The assembly-descriptor element contains application-assembly information.
# 
# The definition of security roles allows you to map assembly roles to one or more
# principals. For example, you may define a run-as principal in the security-identity
# element and include that principal in one or more security-role(s) in the
# assembly descriptor. When called with a run-as role, the callee will see all
# those roles in ctx.isCallerInRole(...)
# 
# Used in: jboss
assembly-descriptor =
  element assembly-descriptor {
    attlist.assembly-descriptor, security-role*, message-destination*
  }
attlist.assembly-descriptor &= empty
#   The security-role element contains the definition of a security role.
#   The definition consists of an the security role name and principal name element(s).
# 
# Used in: assembly-descriptor
# 
# Example:
#		<security-role>
#       <role-name>Manager</role-name>
#       <principal-name>j2ee</principal-name>
#       <principal-name>javajoe</principal-name>
#		</security-role>
security-role =
  element security-role {
    attlist.security-role, role-name, principal-name+
  }
attlist.security-role &= empty
# The role-name element is the name of the role.
# 
# Used in: security-role
role-name = element role-name { attlist.role-name, text }
attlist.role-name &= empty
# The principal-name element is the name of the principal that is mapped
# to the assembly role-name.
# 
# Used in: security-role
principal-name = element principal-name { attlist.principal-name, text }
attlist.principal-name &= empty
# The message-destination element is used to configure the
# jndi-name for a message-destination in ejb-jar.xml
# 
# Used in: assembly-descriptor
message-destination =
  element message-destination {
    attlist.message-destination, message-destination-name, jndi-name
  }
attlist.message-destination &= empty
# The message-destination-name element identifies the
# message-destination. It must match the name in ejb-jar.xml
# 
# Used in: message-destination
message-destination-name =
  element message-destination-name {
    attlist.message-destination-name, text
  }
attlist.message-destination-name &= empty
# The container-configurations element declares the different possible
# container configurations that the beans can use. standardjboss.xml
# provides 15 standard configurations with the following container-names:
#   - Standard CMP 2.x EntityBean
#   - Standard CMP EntityBean
#   - Clustered CMP 2.x EntityBean
#   - Clustered CMP EntityBean
#   - IIOP CMP 2.x EntityBean
#   - IIOP CMP EntityBean
#   - Standard Stateless SessionBean
#   - Clustered Stateless SessionBean
#   - IIOP Stateless SessionBean
#   - Standard Stateful SessionBean
#   - Clustered Stateful SessionBean
#   - IIOP Stateful SessionBean
#   - Standard BMP EntityBean
#   - Clustered BMP EntityBean
#   - IIOP BMP EntityBean
#   - Standard message Driven Bean
# 
# The standard configurations will automatically be used if no custom
# configuration is specified.
# 
# The application assembler can define advanced custom configurations here.
# 
# Used in: jboss
container-configurations =
  element container-configurations {
    attlist.container-configurations, container-configuration*
  }
attlist.container-configurations &= empty
# The container-configuration element describes a configuration for the
# container.
# The different plugins to use are declared here, as well as their
# configurations. The configuration-class attribute is no longer used.
# 
# Used in: container-configurations
container-configuration =
  element container-configuration {
    attlist.container-configuration,
    container-name,
    call-logging?,
    invoker-proxy-binding-name?,
    sync-on-commit-only?,
    insert-after-ejb-post-create?,
    call-ejb-store-on-clean?,
    store-not-flushed?,
    container-interceptors?,
    instance-pool?,
    instance-cache?,
    persistence-manager?,
    web-class-loader?,
    locking-policy?,
    container-cache-conf?,
    container-pool-conf?,
    commit-option?,
    optiond-refresh-rate?,
    security-domain?,
    cluster-config?,
    depends*
  }
# The extends attribute gives the container-name value of the configuration the container-configuration
# is extending. This allows one to specify an extension configuration without having to reiterate all of
# the other duplicate configuration info.
# 
#         <container-configuration extends="Standard Stateful SessionBean">
#             <container-name>Secure Stateless SessionBean</container-name>
#             <security-domain>java:/jaas/other</security-domain>
#         </container-configuration>
attlist.container-configuration &= attribute extends { text }?
# The container-name element gives the name of the configuration being
# defined. Beans may refer to this name in their configuration-name tag.
# 
# Used in: container-configuration
container-name = element container-name { attlist.container-name, text }
attlist.container-name &= empty
# The call-logging element tells if the container must log every method
# invocation for this bean or not. Its value must be true or false.
# 
# Used in: container-configuration
call-logging = element call-logging { attlist.call-logging, text }
attlist.call-logging &= empty
# The invoker-bindings element gives the invokers configuration for an
# ejb container.
# 
# Used in: entity, session, message-driven
invoker-bindings =
  element invoker-bindings { attlist.invoker-bindings, invoker+ }
attlist.invoker-bindings &= empty
#
invoker =
  element invoker {
    attlist.invoker, invoker-proxy-binding-name, jndi-name?, ejb-ref*
  }
attlist.invoker &= empty
# The invoker-proxy-binding-name elements maps to the name element of
# an invoker-proxy-binding definition.
# 
#   Used in: container-configuration, invoker
invoker-proxy-binding-name =
  element invoker-proxy-binding-name {
    attlist.invoker-proxy-binding-name, text
  }
attlist.invoker-proxy-binding-name &= empty
# The sync-on-commit-only element determines the behavior of ejbStore
# calls on finds, selects and removes. If set to true, ejbStore will only be
# called on transaction commit.
sync-on-commit-only =
  element sync-on-commit-only { attlist.sync-on-commit-only, text }
attlist.sync-on-commit-only &= empty
# The insert-after-ejb-post-create element defines when the INSERT
# statement will be executed for created entity instance.
# Possible values are:
# false - the default value, INSERT will be executed after ejbCreate but before
#         ejbPostCreate;
# true - INSERT will be executed after ejbPostCreate.
insert-after-ejb-post-create =
  element insert-after-ejb-post-create {
    attlist.insert-after-ejb-post-create, text
  }
attlist.insert-after-ejb-post-create &= empty
# The call-ejb-store-for-clean says whether ejbStore should be called on clean instances
# at synchronization time. By the spec it should be true. But users wanted it to be false.
# False is the default, meaning ejbStore is called only on dirty instances.
call-ejb-store-on-clean =
  element call-ejb-store-on-clean {
    attlist.call-ejb-store-on-clean, text
  }
attlist.call-ejb-store-on-clean &= empty
# The store-not-flushed says whether dirty instances that could not be evicted
# from the cache should or should not (to prevent potential data inconsistency)
# be stored. The default value is TRUE.
store-not-flushed =
  element store-not-flushed { attlist.store-not-flushed, text }
attlist.store-not-flushed &= empty
# The container-interceptors element gives the chain of Interceptors
# (instances of org.jboss.ejb.Interceptor) that are associated with the container.
# The declared order of the interceptor elements corresponds to the order of the
# interceptor chain.
# 
# Used in: container-configuration
container-interceptors =
  element container-interceptors {
    attlist.container-interceptors, interceptor+
  }
attlist.container-interceptors &= empty
# The client-interceptors defines the home and bean client side interceptor chain
# 
#   Used in: proxy-factory-config
client-interceptors =
  element client-interceptors {
    attlist.client-interceptors, home, bean, list-entity?
  }
# Define whether the ejb proxy should expose an org.jboss.proxy.IClientContainer
# interface to provide access to the invocation context and interceptors.
attlist.client-interceptors &=
  [ a:defaultValue = "false" ]
  attribute exposeContainer { "true" | "false" }?
# The endpoint-interceptors element gives the chain of interceptors
# (instances of org.jboss.proxy.Interceptor) that are associated with the
# message endpoint.
# 
#   Used in: proxy-factory-config for message inflow
endpoint-interceptors =
  element endpoint-interceptors {
    attlist.endpoint-interceptors, interceptor+
  }
attlist.endpoint-interceptors &= empty
# The home element gives the chain of interceptors
# (instances of org.jboss.proxy.Interceptor) that are associated with the home
# proxy and operate in the client VM. The declared order of the interceptor
# elements corresponds to the order of the interceptor chain.
# 
#   Used in: client-interceptors
home = element home { attlist.home, interceptor+ }
attlist.home &= empty
# The bean element gives the chain of interceptors
# (instances of org.jboss.proxy.Interceptor) that are associated with the remote
# proxy and operate in the client VM. The declared order of the interceptor
# elements corresponds to the order of the interceptor chain.
# 
#   Used in: client-interceptors
bean = element bean { attlist.bean, interceptor+ }
attlist.bean &= empty
# The list-entity element gives the chain of interceptors
# (instances of org.jboss.proxy.Interceptor) that are associated with the remote
# proxy and operate in the client VM. The declared order of the interceptor
# elements corresponds to the order of the interceptor chain.
# 
#   Used in: client-interceptors
list-entity = element list-entity { attlist.list-entity, interceptor+ }
attlist.list-entity &= empty
# The interceptor element specifies an instance of org.jboss.ejb.Interceptor
# that is to be added to the container interceptor stack.
# 
# Used in: home, bean, list-entity, endpoint-interceptors
interceptor = element interceptor { attlist.interceptor, any }
# possible content for the TxInterceptorCMT
retry-handlers =
  element retry-handlers { attlist.retry-handlers, handler+ }
attlist.retry-handlers &= empty
handler = element handler { attlist.handler, text }
attlist.handler &= empty
# The transaction attribute is used to indicate what type of container its
# interceptor applies to. It is an enumerated value that can take on one of: Bean,
# Container or Both. A value of Bean indicates that the interceptor should only be
# added to a container for bean-managed transaction.
# A value of Container indicates that the interceptor should only be added to a
# container for container-managed transactions.
# A value of Both indicates that the interceptor should be added to all
# containers. This is the default value if the transaction attribute is not
# explictlygiven.
attlist.interceptor &=
  [ a:defaultValue = "Both" ]
  attribute transaction { "Bean" | "Container" | "Both" }?
# The metricsEnabled attributes is used to indicate if the interceptor
# should only be included when the org.jboss.ejb.ContainerFactory metricsEnabled
# flag is set to true. The allowed values are true and false with false being the
# default if metricsEnabled is not explicitly given.
attlist.interceptor &=
  [ a:defaultValue = "false" ]
  attribute metricsEnabled { "true" | "false" }?
# The call-by-value attribute is used to indicate that the interceptor
# should only be included when the value of the attribute corresponds
# to the value of org.jboss.metadata.BeanMetaData callByValue.
# For example, if a bean defines the element <call-by-value>true</call-by-value>
# then a marshalling invoker interceptor will be used instead of the
# non marshalling optimized invoker interceptor.
attlist.interceptor &= attribute call-by-value { "true" | "false" }?
# The instance-pool element gives the class name of the instance pool
# jboss must use for in this configuration. This class must implement
# the org.jboss.ejb.InstancePool interface. The defaults are:
# - org.jboss.ejb.plugins.EntityInstancePool for entity beans
# - org.jboss.ejb.plugins.StatelessSessionInstancePool for stateless
# session beans.
# - no pool is used for stateful session beans
# 
# Used in: container-configuration
instance-pool = element instance-pool { attlist.instance-pool, text }
attlist.instance-pool &= empty
# The instance-cache element gives the class name of the instance cache
# jboss must use for in this configuration. This class must implement
# the org.jboss.ejb.InstanceCache interface. The defaults are:
# - org.jboss.ejb.plugins.NoPassivationEntityInstanceCache for entity beans
# - org.jboss.ejb.plugins.NoPassivationStatefulSessionInstanceCache for
# stateful session beans.
# - no cache is used for stateless session beans
# 
# Used in: container-configuration
instance-cache = element instance-cache { attlist.instance-cache, text }
attlist.instance-cache &= empty
# The persistence-manager element gives the class name of the persistence
# manager / persistence store jboss must use for in this configuration.
# This class must implement:
# - org.jboss.ejb.EntityPersistenceStore for CMP Entity Beans (default is
# org.jboss.ejb.plugins.jaws.JAWSPersistenceManager)
# - org.jboss.ejb.EntityPersistenceManager for BMP entity beans (default
# is org.jboss.ejb.plugins.BMPPersistenceManager)
# - org.jboss.ejb.StatefulSessionPersistenceManager for stateless session
# beans.
# - no persistence-manager is used for stateless session beans
# 
# Used in: container-configuration
persistence-manager =
  element persistence-manager { attlist.persistence-manager, text }
attlist.persistence-manager &= empty
# The locking-policy element gives the class name of the EJB lock
# implementation JBoss must use for in this configuration. This class must
# implement  the org.jboss.ejb.BeanLock interface. The default is
# org.jboss.ejb.plugins.lock.QueuedPessimisticEJBLock.
# 
# Used in: container-configuration
locking-policy = element locking-policy { attlist.locking-policy, text }
attlist.locking-policy &= empty
# The web-class-loader element gives the class name of the web classloader
# jboss must use for in this configuration. This class must be a subclass
# of org.jboss.web.WebClassLoader. The default is org.jboss.web.WebClassLoader.
# 
# Used in: container-configuration
# Used in: proxy-factory-config
web-class-loader =
  element web-class-loader { attlist.web-class-loader, text }
attlist.web-class-loader &= empty
# The container-cache-conf element holds dynamic configuration data
# for the instance cache.
# jboss does not read directly the subtree for this element: instead,
# it is passed to the instance cache instance (if it implements
# org.jboss.metadata.XmlLoadable) for it to load its parameters.
# 
# Used in: container-configuration
container-cache-conf =
  element container-cache-conf {
    attlist.container-cache-conf,
    cache-policy?,
    cache-policy-conf?,
    cache-policy-conf-other?
  }
attlist.container-cache-conf &= empty
# The implementation class for the cache policy, which controls
# when instances will be passivated, etc.
# 
# Used in: container-cache-conf
cache-policy = element cache-policy { attlist.cache-policy, text }
attlist.cache-policy &= empty
# The configuration settings for the selected cache policy.  This
# is currently only valid for the LRU cache.
# When the cache is the LRU one for the stateful container, the elements
# remover-period and max-bean-life specifies the period of the remover
# task that removes stateful beans (that normally have been passivated)
# that have age greater than the specified max-bean-life element.
# 
# Used in: container-cache-conf (when cache-policy is the LRU cache)
cache-policy-conf =
  element cache-policy-conf {
    attlist.cache-policy-conf,
    min-capacity?,
    max-capacity?,
    remover-period?,
    max-bean-life?,
    overager-period?,
    max-bean-age?,
    resizer-period?,
    max-cache-miss-period?,
    min-cache-miss-period?,
    cache-load-factor?,
    flush-enabled?
  }
attlist.cache-policy-conf &= empty
# The minimum capacity of this cache
min-capacity = element min-capacity { attlist.min-capacity, text }
attlist.min-capacity &= empty
# The maximum capacity of this cache
max-capacity = element max-capacity { attlist.max-capacity, text }
attlist.max-capacity &= empty
# The period of the overager's runs
overager-period =
  element overager-period { attlist.overager-period, text }
attlist.overager-period &= empty
# The period of the remover's runs
remover-period = element remover-period { attlist.remover-period, text }
attlist.remover-period &= empty
# The max-bean-life specifies the period of the remover
# task that removes stateful beans (that normally have been passivated)
# that have age greater than the specified max-bean-life element.
max-bean-life = element max-bean-life { attlist.max-bean-life, text }
attlist.max-bean-life &= empty
# The period of the resizer's runs
resizer-period = element resizer-period { attlist.resizer-period, text }
attlist.resizer-period &= empty
# The age after which a bean is automatically passivated
max-bean-age = element max-bean-age { attlist.max-bean-age, text }
attlist.max-bean-age &= empty
# Shrink cache capacity if there is a cache miss every or more
# this member's value
max-cache-miss-period =
  element max-cache-miss-period { attlist.max-cache-miss-period, text }
attlist.max-cache-miss-period &= empty
# Enlarge cache capacity if there is a cache miss every or less
# this member's value
min-cache-miss-period =
  element min-cache-miss-period { attlist.min-cache-miss-period, text }
attlist.min-cache-miss-period &= empty
# The resizer will always try to keep the cache capacity so that
# the cache is this member's value loaded of cached objects
cache-load-factor =
  element cache-load-factor { attlist.cache-load-factor, text }
attlist.cache-load-factor &= empty
# For the NoPassivationCachePolicy. Can be true or false
flush-enabled = element flush-enabled { attlist.flush-enabled, text }
attlist.flush-enabled &= empty
# Arbitrary XML configuration
cache-policy-conf-other =
  element cache-policy-conf-other {
    attlist.cache-policy-conf-other, any
  }
attlist.cache-policy-conf-other &= empty
# Possible content for the cache-policy-conf-other
partitions = element partitions { attlist.partitions, text }
attlist.partitions &= empty
batch-commit-strategy =
  element batch-commit-strategy { attlist.batch-commit-strategy, text }
attlist.batch-commit-strategy &= empty
invalidable = element invalidable { attlist.invalidable, empty }
attlist.invalidable &= empty
# The container-pool-conf element holds configuration data for the
# instance pool.
# jboss does not read directly the subtree for this element: instead,
# it is passed to the instance pool instance (if it implements
# org.jboss.metadata.XmlLoadable) for it to load its parameters.
# 
# The default instance pools, EntityInstancePool and
# StatelessSessionInstancePool, both accept the following configuration.
# 
# Used in: container-configuration
container-pool-conf =
  element container-pool-conf {
    attlist.container-pool-conf,
    ((MinimumSize?, MaximumSize?, strictMaximumSize?, strictTimeout?)
     | Synchronized)
  }
attlist.container-pool-conf &= empty
# The theoretical minimum size of the pool. Currently unused by JBoss
# EJB pools.
# 
# Used in: invoker-proxy-conf for JMSContainerInvoker
MinimumSize = element MinimumSize { attlist.MinimumSize, text }
attlist.MinimumSize &= empty
# The capacity of the Pool. For pools where reclaim is possible, the pool will
# also be repopulated when the instance is free to be reused.
# This is not an hard limit, if instances are needed when the pool is at
# its MaximumSize, new instances will be created following the demand unless
# a strictMaximumSize of true is specified.
# 
# Used in: container-pool-conf and invoker-proxy-conf for JMSContainerInvoker
MaximumSize = element MaximumSize { attlist.MaximumSize, text }
attlist.MaximumSize &= empty
# A boolean flag indicating if attempts to access the pool will block when
# MaximumSize instances are active. The default is false.
# 
#   Used in: container-pool-conf
strictMaximumSize =
  element strictMaximumSize { attlist.strictMaximumSize, text }
attlist.strictMaximumSize &= empty
# The time in milliseconds to wait for the strictMaximumSize semaphore. The
# default is Long.MAX_VALUE or essentially enternity.
# 
#   Used in: container-pool-conf
strictTimeout = element strictTimeout { attlist.strictTimeout, text }
attlist.strictTimeout &= empty
# Can be true or false.
# Used in SingletonStatelessSessionInstancePool to synchronize access to the SLSB instance.
# 
# Used in: container-pool-conf
Synchronized = element Synchronized { attlist.Synchronized, text }
attlist.Synchronized &= empty
# The number of millis to keep an unused object in the pool. Currently unused by
# JBoss EJB Pools.
# 
# Used in: invoker-proxy-conf for JMSContainerInvoker
KeepAliveMillis =
  element KeepAliveMillis { attlist.KeepAliveMillis, text }
attlist.KeepAliveMillis &= empty
# This option is only used for entity container configurations.
# 
# The commit-option element tells the container which option to use for transactions.
# Its value must be A, B C, or D.
# 
# - option A: the entiry instance has exclusive access to the database. The instance
# stays ready after a transaction.
# - option B: the entity instance does not have exclusive access to the database.
# The state is loaded before the next transaction.
# - option C: same as B, except the container does not keep the instance after commit:
# a passivate is immediately performed after the commit.
# 
# - option D: a lazy update. default is every 30 secs.
#              can be updated with <optiond-refresh-rate>
# 
# See ejb1.1 specification for details (p118).
# 
# Used in: container-configuration
commit-option = element commit-option { attlist.commit-option, text }
attlist.commit-option &= empty
# This element is used to specify the refresh rate of commit option d
optiond-refresh-rate =
  element optiond-refresh-rate { attlist.optiond-refresh-rate, text }
attlist.optiond-refresh-rate &= empty
# ior-security-config element describes the security configuration information for the IOR.
ior-security-config =
  element ior-security-config {
    attlist.ior-security-config,
    transport-config?,
    as-context?,
    sas-context?
  }
attlist.ior-security-config &= empty
# transport-config is the root element for security between the end points
transport-config =
  element transport-config {
    attlist.transport-config,
    integrity,
    confidentiality,
    establish-trust-in-target,
    establish-trust-in-client,
    detect-misordering?,
    detect-replay?
  }
attlist.transport-config &= empty
# integrity element indicates if the server (target) supports integrity protected messages. 
# The valid values are NONE, SUPPORTED or REQUIRED
integrity = element integrity { attlist.integrity, text }
attlist.integrity &= empty
# confidentiality element indicates if the server (target) supports privacy protected 
# messages. The values are NONE, SUPPORTED or REQUIRED
confidentiality =
  element confidentiality { attlist.confidentiality, text }
attlist.confidentiality &= empty
# establish-trust-in-target element indicates if the target is capable of authenticating to a client. 
# The values are NONE or SUPPORTED.
establish-trust-in-target =
  element establish-trust-in-target {
    attlist.establish-trust-in-target, text
  }
attlist.establish-trust-in-target &= empty
# establish-trust-in-client element indicates if the target is capable of authenticating a client. The
# values are NONE, SUPPORTED or REQUIRED.
establish-trust-in-client =
  element establish-trust-in-client {
    attlist.establish-trust-in-client, text
  }
attlist.establish-trust-in-client &= empty
# The optional detect-misordering indicates if the server (target) supports
# detection of message sequence errors. The values are NONE, SUPPORTED or REQUIRED.
detect-misordering =
  element detect-misordering { attlist.detect-misordering, text }
attlist.detect-misordering &= empty
# The optional detect-replay indicates if the server (target) supports detection
# of message replay attempts. The values are NONE, SUPPORTED or REQUIRED.
detect-replay = element detect-replay { attlist.detect-replay, text }
attlist.detect-replay &= empty
# as-context (CSIv2 authentication service) is the element describing the authentication 
# mechanism that will be used to authenticate the client. If specified it will be the 
# username-password mechanism.
as-context =
  element as-context {
    attlist.as-context, auth-method, realm, required
  }
attlist.as-context &= empty
# required element specifies if the authentication method specified is required
# to be used for client authentication. If so the EstablishTrustInClient bit
# will be set in the target_requires field of the AS_Context. The element value
# is either true or false. 
required = element required { attlist.required, text }
attlist.required &= empty
# auth-method element describes the authentication method. The only supported value
# for as-context is USERNAME_PASSWORD
# 
# For port-component, the auth-method element is used to configure the
# authentication mechanism for the web service. As a prerequisite to gaining
# access to any web service which are protected by an authorization
# constraint, a user must have authenticated using the configured
# mechanism. Legal values for this element are "BASIC", or "CLIENT-CERT".
# 
# Used in: as-context, port-component
#
auth-method = element auth-method { attlist.auth-method, text }
attlist.auth-method &= empty
# realm element describes the realm in which the user is authenticated. Must be 
# a valid realm that is registered in server configuration.
realm = element realm { attlist.realm, text }
attlist.realm &= empty
# sas-context (related to CSIv2 security attribute service) element describes 
# the sas-context fields.
sas-context =
  element sas-context { attlist.sas-context, caller-propagation }
attlist.sas-context &= empty
# caller-propagation element indicates if the target will accept propagated caller identities
# The values are NONE or SUPPORTED.
caller-propagation =
  element caller-propagation { attlist.caller-propagation, text }
attlist.caller-propagation &= empty
# The port-component element specifies a mapping from a webservice
# port-component whose service-impl-bean/ejb-link value maps to an ejb.
# 
# Used in: session
port-component =
  element port-component {
    attlist.port-component,
    port-component-name,
    port-component-uri?,
    auth-method?,
    transport-guarantee?
  }
attlist.port-component &= empty
# Maps to the port-component-name in the webservices.xml descriptor.
# 
# Used in: port-component
port-component-name =
  element port-component-name { attlist.port-component-name, text }
attlist.port-component-name &= empty
# Relative path that is appended to the <context-root> element to form fully qualified
# endpoint address for a web service endpoint. 
# 
# For backwards compatibility, it may also be the absolute path starting with web context root 
# to form fully qualified endpoint address for a web service endpoint. In this case, the port component uri
# must contain at least two token seperated by '/'. The first token is the web context root,
# which must be identical among all port component uris in a given deployment.
# 
# Used in: port-component
port-component-uri =
  element port-component-uri { attlist.port-component-uri, text }
attlist.port-component-uri &= empty
# The transport-guarantee element specifies that the communication
# between client and server should be NONE, INTEGRAL, or
# CONFIDENTIAL. NONE means that the application does not require any
# transport guarantees. A value of INTEGRAL means that the application
# requires that the data sent between the client and server be sent in
# such a way that it can't be changed in transit. CONFIDENTIAL means
# that the application requires that the data be transmitted in a
# fashion that prevents other entities from observing the contents of
# the transmission. In most cases, the presence of the INTEGRAL or
# CONFIDENTIAL flag will indicate that the use of SSL is required.
# 
# Used in: port-component
transport-guarantee =
  element transport-guarantee { attlist.transport-guarantee, text }
attlist.transport-guarantee &= empty
# Activation config
# 
# used in message-driven and proxy-factory-config
activation-config =
  element activation-config {
    attlist.activation-config, activation-config-property*
  }
attlist.activation-config &= empty
# Activation config properties 
# 
# used in activation-config
activation-config-property =
  element activation-config-property {
    attlist.activation-config-property,
    activation-config-property-name,
    activation-config-property-value
  }
attlist.activation-config-property &= empty
# Activation config property name
# 
# used in activation-config-property
activation-config-property-name =
  element activation-config-property-name {
    attlist.activation-config-property-name, text
  }
attlist.activation-config-property-name &= empty
# Activation config property value
# 
# used in activation-config-property
activation-config-property-value =
  element activation-config-property-value {
    attlist.activation-config-property-value, text
  }
attlist.activation-config-property-value &= empty
start =
  retry-handlers
  | partitions
  | batch-commit-strategy
  | invalidable
  | jboss
any =
  (element * {
     attribute * { text }*,
     any
   }
   | text)*
